CPU，内存，I/O速度不一致，导致运行效率问题，多线程并发执行可以提高效率，带来了并发问题；

# 可见性
线程A修改共享变量后，线程B能够立刻看见，称为可见性；
CPU和内存之间存在CPU缓存，多核CPU，每个线程在不同的核上，操作不同的缓存，内存中的一个变量，会在不同的核上，有不同的副本，导致并发问题；在Java中，每个线程有自己工作内存，用于保存主内存中的副本，不同副本之间的共享变量同步问题，这和CPU缓存是同一个问题；

***JVM内存模型和主内存，CPU寄存器，CPU缓存的对应性？***

# 原子性
一个或多个操作在CPU执行过程中，不会被中断，称为CPU的原子性；而在我们的实践开发中，面对高级语言编程，某个操作实际是由多个CPU指令组成，不具备CPU的原子性，使得在线程切换时，导致的并发问题；

# 有序性
编译器为了优化性能，会在不修改逻辑的情况下，改变代码执行顺序；

双重检查锁创建单例产生的空指针问题？

缓存，线程，编译优化的目的是提高代码执行效率，但缓存带来的可见性问题，线程切换带来的原子性问题，编译优化带来的有序性问题会导致并发问题；

# Java内存模型
# Happen-Before六原则

# 管程

# 读写锁

# 乐观锁&悲观锁

# ReadWriteLock
# StampedLock
