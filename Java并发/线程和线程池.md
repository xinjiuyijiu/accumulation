# 线程的生命周期
![title](https://raw.githubusercontent.com/xinjiuyijiu/NoteImages/master/gitnote/2020/07/03/thread_lifecycle-1593740765337.png)
线程的生命周期包括五种状态：
1. 初始状态：线程在编程语言层被创建，但还未被系统创建，所以不被允许分配CPU；
2. 可运行状态：线程被操作系统创建，可以分配CPU执行；
3. 运行状态：线程被分配了CPU，正在执行；
4. 休眠状态：线程阻塞进入休眠状态，释放CPU，该状态下的线程永远无法获取CPU；
5. 终止状态：线程执行完成或者出现异常会进入终止状态，线程结束运行；
## Java中线程的生命周期

<img src="https://raw.githubusercontent.com/xinjiuyijiu/NoteImages/master/gitnote/2020/07/03/java_thread_lifecycle-1593745120627.png" width="80%" />

Java语言中对线程的生命周期做了细化和调整，属于JVM层的线程状态：
1. NEW 初始化状态
2. RUNNABLE 可运行/运行状态
3. BLOCKED 阻塞状态
4. WAITING 无时限等待
5. TIMED_WAITING 有时限等待
6. TERMINATED 终止状态

Java中相较于通用的“五态模型”，合并了可运行和运行状态，因为JVM将线程的调度交给了系统，并不关心这两个状态；将休眠状态细分成BLOCKED，WAITING，TIMED_WAITING这三种状态;“五态模型”一般是针对CPU对线程的调度，而Java的六种线程状态，关注的是所有操作对线程的状态，比如阻塞式I/O操作，对于“五态模型”，CPU认为线程被阻塞了，处于BLOCKED状态，而对于Java线程状态，线程I/O阻塞时，线程无法被CPU执行，但可能正在被其他设备执行，所以处于RUNNABLE状态；

Java中六种线程状态的相互转换（和系统线程状态有差异）：
- NEW到RUNNABLE的转换
  new Thread创建线程后，调用线程的start方法，线程被系统调用；

- RUNNABLE与BLOCKED的转换
  synchronized互斥锁，当某个线程获取锁后，其它线程无法获取，进入到BLOCKED状态，当线程重新获取锁后，由BLOCKED状态变为RUNNABLE状态
  
- RUNNABLE与WAITING的转换
获取synchronized锁的线程，调用无参数wait方法，线程进入WAITTING状态；线程A中调用线程B.join，线程A会进入WAITING状态，直到线程B执行完成；LockSupport是java SDK并发中Lock锁的实现基础，调用park方法，线程进入WAITTING休眠状态；
  
- RUNNABLE与TIMED_WAITING的转换
调用Thread.Sleep(time),Object.wait(time),Thread.join(time),LockSupport.park(time)这些带超时参数的方法，会让线程进入TIMED_WAITTING状态；

- RUNNABLE到TERMINATED的转换
线程执行完成后会终止，执行过程中抛出异常，也会导致线程终止，另外通过interrupt方法强行中断线程运行，这三种方式都能导致线程由RUNNABLE进入到TERMINATED状态；
interrupt中断线程运行的方式，在调用interrupt方法通知线程中断后，线程不一定会立即中断，有机会执行后序操作，或者无视中断请求，线程被interrupt后通过两种方式受到通知：

	- 异常通知，WATING，TIMED_WAITING状态下的线程，被interrupt时，会回到RUNNABLE状态，然后抛出InterruptedException异常；RUNNABLE状态下的线程，阻塞在某个I/O操作时，会抛出ClosedByInterruptException异常;

	- 主动检测，RUNNABLE状态的线程，如果没有阻塞在I/O上，通过调用isInterrupted，判断是否被终止；


# 线程池**ThreadPoolExecutor**：
线程的创建和销毁需要付出较高的代价，通过池化技术高效的利用线程。

**工作线程**的数量：
0～～～核心线程数量～～～最大线程数量。

**阻塞队列**，用于处理工作线程已达到核心线程数量，阻塞队列会存放这些任务，如果阻塞队列被装满，则会创建新的工作线程处理这些任务，直到工作线程数量达到最大线程数量，如果工作线程数量达到最大线程数量，那么会触发**饱和策略**（抛异常，丢弃任务，替换任务。。。）
，如果是**无界的阻塞队列**，则没有限制，并且因为不会被装满，所以工作线程最大数量不会超过核心线程数量。
**核心线程**的身份不是由创建者决定的，而是和工作线程数量有关，如果工作线程数量大于核心线程数，则部分工作线程可能被抛弃，留下来的就是核心线程，相反如果工作线程数量小于核心线程数量，则它们都是核心线程。

**线程的阻塞和非阻塞：**

**线程池的分类：**