# 线程的生命周期
![title](https://raw.githubusercontent.com/xinjiuyijiu/NoteImages/master/gitnote/2020/07/03/thread_lifecycle-1593740765337.png)
线程的生命周期包括五种状态：
1. 初始状态：线程在编程语言层被创建，但还未被系统创建，所以不被允许分配CPU；
2. 可运行状态：线程被操作系统创建，可以分配CPU执行；
3. 运行状态：线程被分配了CPU，正在执行；
4. 休眠状态：线程阻塞进入休眠状态，释放CPU，该状态下的线程永远无法获取CPU；
5. 终止状态：线程执行完成或者出现异常会进入终止状态，线程结束运行；
## Java中线程的生命周期

Java语言中对线程的生命周期做了细化和调整：
1. NEW 初始化状态
2. RUNNABLE 可运行/运行状态
3. BLOCKED 阻塞状态
4. WAITING 无时限等待
5. TIMED_WAITING 有时限等待
6. TERMINATED 终止状态
Java中相较于通用的“五态模型”，合并了可运行和运行状态，因为JVM将线程的调度交给了系统，并不关心这两个状态；将休眠状态细分成BLOCKED，WAITING，TIMED_WAITING这三种状态，

线程池**ThreadPoolExecutor**：
线程的创建和销毁需要付出较高的代价，通过池化技术高效的利用线程。

**工作线程**的数量：
0～～～核心线程数量～～～最大线程数量。

**阻塞队列**，用于处理工作线程已达到核心线程数量，阻塞队列会存放这些任务，如果阻塞队列被装满，则会创建新的工作线程处理这些任务，直到工作线程数量达到最大线程数量，如果工作线程数量达到最大线程数量，那么会触发**饱和策略**（抛异常，丢弃任务，替换任务。。。）
，如果是**无界的阻塞队列**，则没有限制，并且因为不会被装满，所以工作线程最大数量不会超过核心线程数量。
**核心线程**的身份不是由创建者决定的，而是和工作线程数量有关，如果工作线程数量大于核心线程数，则部分工作线程可能被抛弃，留下来的就是核心线程，相反如果工作线程数量小于核心线程数量，则它们都是核心线程。

**线程的阻塞和非阻塞：**

**线程池的分类：**