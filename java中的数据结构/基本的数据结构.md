# 数组

连续的内存地址，存储相同类型的数据（这样才能分配合理的内存空间），创建前需要指定分配大小；
通过数组下标随机访问数据（其实是内存地址偏移）；
# 链表
不连续的内存地址，一个个节点依次链接，每个节点包含了存储的数据和下一个节点的地址；只能通过遍历查找获取指定数据；
- 单向链表：每个节点存储了下一个节点的地址；
- 双向链表：每个节点存储了上一个节点和下一个节点的地址；
- 循环链表：尾结点存储了首节点的地址，使得首尾相连；
- 双向循环链表：双向链表和循环链表相结合；

Java LinkedList：双向链表 doubly-link，双向队列（deque）

Java LruCache: 使用LinkedHashMap 头部插入新数据，尾部移除旧数据
   LRU：Least Recently Use 最近最少使用淘汰算法，或者说最久没有使用的被淘汰。
set：如果链表中存在该数据，将该节点移动到头部，重置value；如果链表中不存在该数据，新建节点并放在头部；
        get：如果链表中存在该数据，奖盖节点移动到头部。
        remove：如果缓存已满，放入新数据时，从链尾部开始移除。
   LFU：Least Frequency Use 最近最不常用淘汰算法，或者说使用次数最少的被淘汰。

回文字符串的判断？单链表，快慢指针，使用快指针找到中心位置，反转前部分的链，前部分链和后部分链比较。
 数组，正向和反向遍历比较，所有的数都相等（类似栈的概念）。
# 栈
一种操作受限的线性表，允许一端的插入和删除操作，LIFO 先进后出；可以使用数组或者链表实现栈数据结构，顺序栈，链式栈；
    函数调用栈：每个线程都被分配了一个栈，用来处理函数的调用；
编译器的表达式求值：使用两个栈：操作数栈，运算符栈；
字符串括号匹配：左括号入栈，遇到右括号取栈顶数据是否为匹配的左括号，直到栈为空以及字符串扫描完成；
浏览器中的前进和后退功能：使用两个栈X,Y，新增网页入栈X，点击后退，将栈X的数据出栈后入栈Y，直到栈X为空，点击前进，将栈Y的数据出栈后入栈X，直到栈Y为空；
     JVM中的虚拟机栈和数据结构中的栈是两种概念；
    Java的Stack使用了Vector来实现；
# 队列
类似栈是一种操作受限的线性表，允许一段插入，另一端删除，FIFO先进先出；可以使用数组或者链表实现队列数据结构，顺序队列，练市队列；
      循环队列，阻塞队列，并发队列？
      线程池的排队请求队列？
- 循环队列
- 阻塞队列
# 散列表
把任意长度的输入数据变成固定长度的输出，一般来说散列表长度远小于数据长度；应该算是对数组这种数据结构的扩展；
     key -> hash函数（散列函数）-> hash值（散列值）
散列冲突：无法避免不同的key生成相同的hash值得情况，只能通过设计更加优秀的散列函数来减小冲突次数；如果发生了散列冲突可以通过开放寻址法和链表法来解决：
     开放寻址法：核心思想是将冲突的值放入到空slot（bucket）中；线性探测会从当前冲突位置继续向下寻找空slot，遇到则插入，否则知道遍历完整张表；
          二次探测：表示每次查找位置为冲突位置+1²，2²...；双重散列：表示使用一组hash函数，如果遇到冲突继续选择新的hash函数，知道解决冲突问题；rehash
    链表法：每个slot对应一条链表，所以相同位置的数据依次放入链表中；
  链表法解决冲突相比开放寻址法更普遍；

       装载因子：填入表的元素数量/散列表长度表示装载因子，因此装载因子越大表示剩余的空白slot越少，发生散列冲突的概率越大，导致查询效率越低；

     Word中的单词拼写检查：使用散列表，比如Java的HashSet；
        Bitmap算法：有点计数排序的味道；
        布隆过滤器？
哈希表碰撞攻击？散列函数设计过于简单，导致数据基本放在一个bucket中，从而使得退化成单链表的查询，时间复杂度由O（1）退化成了O（n）；

      动态缩容。
      如何避免低效的扩容？比如1GB的散列表，插入新数据时需要扩容，此时如果一次性搬移数据，则会非常慢，如果每次插入新数据时，分批将旧的散列表数据迁移到新的散列表，则能解决该问题，查询数据时，则先查询新散列表，再查询旧散列表即可。
分析JavaHashMap的动态扩容和散列函数？
      Java的HashMap中，当链表长度>8时会转换成红黑树，<=8时会转换成链表；
   散列表和链表经常一起使用？
      LRU缓存淘汰算法；
Redis跳表；
LinkedHashMap（双链表）:这里的Linked区别于前面散列表的解决hash冲突的链表法，每个节点同时存在于两条链中，一条链是链表法用于解决冲突，另一条链是双向链表，用于有序遍历数据；


Hash算法：一种摘要算法或者签名算法；
1.安全加密：比如用户密码+salt后md5加密；
2.唯一标识：可用于文件完整性校验，数据校验；
3.散列函数：散列表的设计，散列函数并不关心数据解密问题，而是关注数据随机分    布以及计算效率；
4.负载均衡处理会话粘滞，保持某个客户端的会话（登录）始终在一台服务器上；
5.数据切片：大规模数据处理MapReduce，分布式处理数据；
6.分布式存储：一致性哈希算法解决分布式缓存的扩容缩容导致的数据迁移；
    
Hash冲突和鸽巢原理。
数据库的脱库？区块链加密，pow工作量证明？
一致性hash算法？

# 跳表
对链表添加多级索引节点层，使得数据的查找时间为O（logn），但是它的空间复杂度也为O（n），典型的空间换时间。Redis使用了跳表。
跳表和红黑树？
# 树
#### 二叉树
每个节点最多两个子节点的树结构；
#### 满二叉树：
除了最后一层的叶子结点，其它每个树节点都有两个子节点；
#### 完全二叉树：
 n层二叉树，其中n-1层树是满二叉树，最后一层从左至右连续的节点（可以不满），所以完全 
  二叉树的节点编号一定是2^(n-1)~~2^n-1，所以满二叉树也应该是完全二叉树
#### 二叉搜索树

#### 红黑树
#### 堆
#### 树的遍历
