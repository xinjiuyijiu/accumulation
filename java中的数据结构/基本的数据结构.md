# 数组

连续的内存地址，存储相同类型的数据（这样才能分配合理的内存空间），创建前需要指定分配大小；
通过数组下标随机访问数据（其实是内存地址偏移）；
# 链表
不连续的内存地址，一个个节点依次链接，每个节点包含了存储的数据和下一个节点的地址；只能通过遍历查找获取指定数据；
- 单向链表：每个节点存储了下一个节点的地址；
- 双向链表：每个节点存储了上一个节点和下一个节点的地址；
- 循环链表：尾结点存储了首节点的地址，使得首尾相连；
- 双向循环链表：双向链表和循环链表相结合；

Java LinkedList：双向链表 doubly-link，双向队列（deque）

Java LruCache: 使用LinkedHashMap 头部插入新数据，尾部移除旧数据
  - LRU：Least Recently Use 最近最少使用淘汰算法，或者说最久没有使用的被淘汰。
set：如果链表中存在该数据，将该节点移动到头部，重置value；如果链表中不存在该数据，新建节点并放在头部；
       - get：如果链表中存在该数据，奖盖节点移动到头部。
       - remove：如果缓存已满，放入新数据时，从链尾部开始移除。

  - LFU：Least Frequency Use 最近最不常用淘汰算法，或者说使用次数最少的被淘汰。

***回文字符串的判断？***
- 单链表，快慢指针，使用快指针找到中心位置，反转前部分的链，前部分链和后部分链比较。
快指针2步，慢指针1步，快指针遍历真个链表后，慢指针刚好走到中间；
慢指针走到中间的过程中，反转前半部分链表,慢指针走到中间位置后，新的指针反向遍历，慢指针继续前进，比较每个节点是否相等；
当然在新指针遍历期间，还可以反转前半部分列表，使得其复原；

- 数组，正向和反向遍历比较，所有的数都相等（类似栈的概念）。
# 栈
一种操作受限的线性表，允许一端的插入和删除操作，LIFO 先进后出；可以使用数组或者链表实现栈数据结构，顺序栈，链式栈；

1. 函数调用栈：每个线程都被分配了一个栈，用来处理函数的调用；
**++2. 编译器的表达式求值：使用两个栈：操作数栈，运算符栈；++**
3. 字符串括号匹配：左括号入栈，遇到右括号取栈顶数据是否为匹配的左括号，直到栈为空以及字符串扫描完成；
4. 浏览器中的前进和后退功能：使用两个栈X,Y，新增网页入栈X，点击后退，将栈X的数据出栈后入栈Y，直到栈X为空，点击前进，将栈Y的数据出栈后入栈X，直到栈Y为空；

JVM中的虚拟机栈和数据结构中的栈是两种概念；
Java的Stack使用了Vector来实现；

# 队列
类似栈是一种操作受限的线性表，允许一段插入，另一端删除，FIFO先进先出；可以使用数组或者链表实现队列数据结构，顺序队列，链式队列；

***循环队列，阻塞队列，并发队列***
***线程池的排队请求队列？***
- 循环队列
- 阻塞队列

# 散列表
把任意长度的输入数据变成固定长度的输出，一般来说散列表长度远小于数据长度；应该算是对数组这种数据结构的扩展；

       key -> hash函数（散列函数）-> hash值（散列值）

散列冲突：无法避免不同的key生成相同的hash值得情况，只能通过设计更加优秀的散列函数来减小冲突次数；如果发生了散列冲突可以通过开放寻址法和链表法来解决：
  - 开放寻址法：核心思想是将冲突的值放入到空slot（bucket）中；线性探测会从当前冲突位置继续向下寻找空slot，遇到则插入，否则知道遍历完整张表；
  - 二次探测：表示每次查找位置为冲突位置+1²，2²...；双重散列：表示使用一组hash函数，如果遇到冲突继续选择新的hash函数，知道解决冲突问题；rehash
  - 链表法：每个slot对应一条链表，所以相同位置的数据依次放入链表中；
  链表法解决冲突相比开放寻址法更普遍；

**装载因子**：填入表的元素数量/散列表长度表示装载因子，因此装载因子越大表示剩余的空白slot越少，发生散列冲突的概率越大，导致查询效率越低；

- Word中的单词拼写检查：使用散列表，比如Java的HashSet；
- Bitmap算法：有点计数排序的味道；
- 布隆过滤器？

***哈希表碰撞攻击？***
散列函数设计过于简单，导致数据基本放在一个bucket中，从而使得退化成单链表的查询，时间复杂度由O（1）退化成了O（n）；

**动态缩容**
**如何避免低效的扩容？**
比如1GB的散列表，插入新数据时需要扩容，此时如果一次性搬移数据，则会非常慢，如果每次插入新数据时，分批将旧的散列表数据迁移到新的散列表，则能解决该问题，查询数据时，则先查询新散列表，再查询旧散列表即可。

***分析Java HashMap的动态扩容和散列函数？***
      Java的HashMap中，当链表长度>8时会转换成红黑树，<=8时会转换成链表；

***散列表和链表经常一起使用？***
- LRU缓存淘汰算法；
- Redis跳表；
- LinkedHashMap（双链表）:这里的Linked区别于前面散列表的解决hash冲突的链表法，每个节点同时存在于两条链中，一条链是链表法用于解决冲突，另一条链是双向链表，用于有序遍历数据；


**Hash算法**一种摘要算法或者签名算法；

1. 安全加密：比如用户密码+salt后md5加密；
2. 唯一标识：可用于文件完整性校验，数据校验；
3. 散列函数：散列表的设计，散列函数并不关心数据解密问题，而是关注数据随机分    布以及计算效率；
4. 负载均衡处理会话粘滞，保持某个客户端的会话（登录）始终在一台服务器上；
5. 数据切片：大规模数据处理MapReduce，分布式处理数据；
6. 分布式存储：一致性哈希算法解决分布式缓存的扩容缩容导致的数据迁移；
    
Hash冲突和鸽巢原理。
数据库的脱库？区块链加密，pow工作量证明？
***一致性hash算法？***

# 跳表
对链表添加多级索引节点层，使得数据的查找时间为O（logn），但是它的空间复杂度也为O（n），典型的空间换时间。Redis使用了跳表。
跳表和红黑树？
# 树：
根节点：没有父节点的节点；
叶子节点：没有子节点的节点；
节点的高度：节点到叶子节点的最长路径；
节点的深度：根节点到该节点的边数量；
节点的层数：节点的深度+1；
树的高度：根节点的高度；

**满二叉树**：叶子结点全部都在最底层的二叉树；
**完全二叉树**：如果n个节点，从上至下，从左至右编号，每个节点的编号和在满二叉树中的编号相同，则是完全二叉树；
   也就是说：最后一层是从最左边的连续的叶子节点，其它层的左右节点都存在；

 为什么会存在完全二叉树的概念？它的意义是什么？

 树的两种存储方式：

   - 链式存储：每个node存在左右指针，指向存在的左右子节点；
   - 顺序存储：按照满二叉树的节点编号，存储在数组中（第0个位置为空）；
    
  根据这两种存储方式可见，完全二叉树是连续编号的，使用顺序存储简单方便，非完全二叉树如果使用顺序存储，会使得数组数据之间留下空白，存储效率变低，而使用链式存储，需要额外的左右指针空间；

**二叉树的遍历：**
   前序遍历，中序遍历，后序遍历：这里的前序，中序，后序，都是相对父节点而言的；
   - 前序遍历：父节点（根节点） -> 左节点（父节点，左节点，右节点，递归调用） -> 右节点（父节点，左节点，右节点，递归调用）
   - 中序遍历：左节点（左节点，父节点，右节点，递归调用）-> 父节点（根节点）-> 右节点（左节点，父节点，右节点，递归调用）
   - 后序遍历：左节点（左节点，右节点，父节点，递归调用） -> 右节点（左节点，右节点，父节点，递归调用） ->  父节点（根节点）

   - 按层遍历？从根节点开始加入队列中，一次取出，然后将它的左右节点放入队列，知道队列为空；
   
   卡特兰数：n个不重复的数，可以构成多少种二叉树？下楼梯的问题？

 二叉查找树：又称做二叉排序树，二叉搜索树；
    所有左子树的节点值小于根节点，所有右子树的节点值大于根节点，并且左子树，右字数均为二叉查找树；
    
- 数据的查找
- 数据的插入
- 数据的删除：分为三种情况:
	1. 被删除的节点是叶子结点；
	2. 被删除的节点只有一个子节点；
	3. 被删除的节点有两个子节点，将右子数的最小节点替换该删除节点；
	   也可以使用标记法，标记被删除的节点（不删除该节点）；

二叉查找树支持的其它特性：
- 快速查找最大，最小值节点；
- 快速查找前驱节点，后继结点（按中序遍历顺序）；
- 中序遍历能够有序输出（为什么叫二叉排序树的理由）；

 实际的树节点存储数据是对象的某个字段，该字段作为key，其它字段为卫星数据。

 数据重复的二叉查找树，如何处理？
   类似散列表处理散列冲突一样，分为两种方法：
   方法1：对值相同的节点，使用动态扩容数组或者链表存储这些相同的值，类似链表法；
   方法2：更适合的是类似线性探测的方法，将相同的值认为是大于该值得节点；这样插入，查找，删除，还要继续处理该节点右子树的数据；

 二叉查找树的时间复杂度？

       和树的高度成正比，如果树的高度等于节点数，此时树结构已经退化成为了单链表，时间复杂度为O（n）；如果是完全二叉树（或者满二叉树），此时的时间复杂度为O（logn），接近于树的高度O（log2n）；也就是说如果树的结构越不平衡，时间复杂度越高；因此需要一种平衡的二叉查找树；

二叉查找树和散列表的比较？

获取二叉树的高度？

方法1：深度递归：左右子树高度递归 ； 
方法2：层次遍历，每遍历完一层+1；
   
**平衡二叉查找树**，严格意义上是指，任意节点的左右子树的高度不超过1（比如AVL树）；为了解决二叉查找树，在插入，删除操作后出现树高度远大于log2n的情况，导致插入，删除，查找效率降低的问题；

而实际使用中，不需要遵守严格意义上的平衡二叉树，只需要树的高度不会太超过log2n，使得左右子树不太失衡即可，而红黑树就是这样的一种平衡二叉查找树。

**红黑树**：性质如下：
1. 根节点是黑色；
2. 所有叶子结点（null）是黑色；
3. 红色节点不连续，也就是说红色节点的子节点一定是黑色；
4. 任意节点到叶子结点的所有路径下的黑节点数量相等，也就是说任意节点的子节点如果是黑色节点，那么该任意节点一定存在两个子节点；也就是说红黑树是黑色完美平衡的二叉查找树（按照该规则，那么即使根节点的左子树全部为黑节点，那么右子树最大高度为左子树的两倍，多的高度为红节点，这样最坏时间复杂度也仅仅为O（2logn））；

红黑树节点Node {key,value,left,right,parent,color}

 **如何保持红黑树的平衡（保持黑色节点平衡）？**
   左旋节点，右旋节点，节点变色：
  假设插入节点为I，父节点为P，叔叔节点为U，祖父节点为GP，正在处理的节点是关注节点。自平衡是个不断迭代调整的过程，自底向上，不断改变关注节点，不断迭代调整，知道整个树黑色平衡；

 插入节点（都是叶子节点）操作的自平衡：
如果I为根节点，设为黑色
如果P为黑色，I设为红色即可；
如果P为红色：
1.如果U为红色：
    GP红色，P，S黑色，I红色，将GP设为关注点，继续进行插入自平衡操作；
2.如果U为黑色：
    
3.如果U不存在：

删除节点操作的自平衡：

红黑树的叶节点为什么是黑色null？
   首先新节点的插入位置，一定是叶子节点，其次，如果叶子结点是红色，则会违反红色节点不相连的规则（当然可以调整，但是不符合一般的调整方法），且会增加平衡的复杂性；

红黑树和2-3树的关系？由2-3树演化而来。

Java中的TreeMap源码？

递归树：使用递归树分析递归算法的时间复杂度。

# 堆：
是一种特殊的二叉树结构，它是一个完全二叉树；它的每个节点的值大于等于（或者小于等于）子节点的值。
   根节点为最大值的堆是大顶堆，根节点为最小值的堆是小顶堆；
   因为是完全二叉树，使用数组存储；

  插入一个数据：采用自下而上的堆化，知道满足堆定义；
  删除一个数据：将最后一个节点替换要删除的节点，然后采用自上而下的堆化，知道满足堆定义；
    这样插入和删除操作后仍然是完全二叉树；
   插入和删除一个数据的时间复杂度为O（logn）

# 堆排序：
  1. 建堆：将一个数组原地建成一个堆；
         方法1：使用插入一个数据的堆化方法，依次插入数据，有点插入排序的味道；
         方法2：使用删除一个数据的堆化方法，从最后一个子树（最后一个非叶子结点）开始，保证每一个子树都自上而下的堆化，直到整棵树完成；

  2. 排序：将建好的大顶推或者小顶堆进行排序；
        使用删除堆顶节点的方法（因为是最大或者最小），然后堆化，不断的重复上述两个过程，知道树为空；
   
 堆排序和快速排序的比较，都是O(nlogn)和原地排序，**为什么更喜欢使用快速排序**？

      堆排序的数据访问不是连续的，比如在根节点堆化时，可能会选择（1,2,4,8）永远不会出现（1,2,3...）这样的序列，因为分叉了，这样对cpu的缓存读取不太方便，因为cpu 是缓存的一个连续的内存块；

      堆排序会出现更多的交换次数，建堆时，可能会打乱某些有序的序列，然后再堆化排序，而快排不会出现这样的情况；

  n个节点的完全二叉树，第一个叶子结点是第n/2+1个节点？
    想想最后一个节点的父节点，位置是n/2，下一个节点是n/2+1。

 **堆结构的实际应用：**
 哪些应用？
	- 优先级队列；
	- 合并有序小文件；
	- 高性能定时器；
	 
**TopK的问题：**
   维护一个k个节点的小顶堆；

**求中位数或者百分比位置的数：**
   一个大顶堆，一个小顶堆，大顶堆的根节点值小于小顶堆的根节点值，并且大顶堆和小顶堆的节点数按照比例分配；

**热门搜索Top10；**

 Java集合中那些使用了堆？PriorityQueue 小顶堆；

MySQL/SQlite数据库使用了哪些排序算法？

# 图
