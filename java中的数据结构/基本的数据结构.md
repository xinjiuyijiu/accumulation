# 数组

连续的内存地址，存储相同类型的数据（这样才能分配合理的内存空间），创建前需要指定分配大小；
通过数组下标随机访问数据（其实是内存地址偏移）；
# 链表
不连续的内存地址，一个个节点依次链接，每个节点包含了存储的数据和下一个节点的地址；只能通过遍历查找获取指定数据；
- 单向链表：每个节点存储了下一个节点的地址；
- 双向链表：每个节点存储了上一个节点和下一个节点的地址；
- 循环链表：尾结点存储了首节点的地址，使得首尾相连；
- 双向循环链表：双向链表和循环链表相结合；

Java LinkedList：双向链表 doubly-link，双向队列（deque）

Java LruCache: 使用LinkedHashMap 头部插入新数据，尾部移除旧数据
   LRU：Least Recently Use 最近最少使用淘汰算法，或者说最久没有使用的被淘汰。
set：如果链表中存在该数据，将该节点移动到头部，重置value；如果链表中不存在该数据，新建节点并放在头部；
        get：如果链表中存在该数据，奖盖节点移动到头部。
        remove：如果缓存已满，放入新数据时，从链尾部开始移除。
   LFU：Least Frequency Use 最近最不常用淘汰算法，或者说使用次数最少的被淘汰。

回文字符串的判断？单链表，快慢指针，使用快指针找到中心位置，反转前部分的链，前部分链和后部分链比较。
 数组，正向和反向遍历比较，所有的数都相等（类似栈的概念）。
# 栈
一种操作受限的线性表，允许一端的插入和删除操作，LIFO 先进后出；可以使用数组或者链表实现栈数据结构，顺序栈，链式栈；
    函数调用栈：每个线程都被分配了一个栈，用来处理函数的调用；
编译器的表达式求值：使用两个栈：操作数栈，运算符栈；
字符串括号匹配：左括号入栈，遇到右括号取栈顶数据是否为匹配的左括号，直到栈为空以及字符串扫描完成；
浏览器中的前进和后退功能：使用两个栈X,Y，新增网页入栈X，点击后退，将栈X的数据出栈后入栈Y，直到栈X为空，点击前进，将栈Y的数据出栈后入栈X，直到栈Y为空；
     JVM中的虚拟机栈和数据结构中的栈是两种概念；
    Java的Stack使用了Vector来实现；
# 队列
类似栈是一种操作受限的线性表，允许一段插入，另一端删除，FIFO先进先出；可以使用数组或者链表实现队列数据结构，顺序队列，练市队列；
      循环队列，阻塞队列，并发队列？
      线程池的排队请求队列？
- 循环队列
- 阻塞队列
# 散列表
通过hash函数将一组数据映射到数组中存储，使得具有数组随机访问的特性；
hash冲突：在通过hash函数将数据映射的过程中，可能出现不同数据产生相同hash结果的情况，导致在散列表同一个位置出现多个数据；
# 跳表
对链表添加多级索引节点层，使得数据的查找时间为O（logn），但是它的空间复杂度也为O（n），典型的空间换时间。Redis使用了跳表。
跳表和红黑树？
# 树
#### 二叉树
每个节点最多两个子节点的树结构；
#### 满二叉树：
除了最后一层的叶子结点，其它每个树节点都有两个子节点；
#### 完全二叉树：
 n层二叉树，其中n-1层树是满二叉树，最后一层从左至右连续的节点（可以不满），所以完全 
  二叉树的节点编号一定是2^(n-1)~~2^n-1，所以满二叉树也应该是完全二叉树
#### 二叉搜索树

#### 红黑树
#### 堆
#### 树的遍历
