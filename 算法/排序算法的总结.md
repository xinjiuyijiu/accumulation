 冒泡，选择，插入排序：时间复杂度O（n²），空间复杂度O（1）（因此也叫作原地排序）；
快速排序，归并排序：时间复杂度O（nlogn）；
桶，计数，基数：时间复杂度O（n），因此又被称为线性排序

排序算法的稳定性：如果一组数据中有两个相等的数，经过排序后，他们的顺序没有发生变化，那么就是稳定的排序算法；
    比如：一组订单，按照金额排序，金额相同的订单则按照时间先后顺序排序，解决办法是：先按照时间排序，然后使用稳定的排序方法进行金额排序；

冒泡排序（交换排序的一种）：两两交换，每次都确定一个数字的位置，多次冒泡后确定所有的位置；

 从三个方面来分析冒泡排序算法：
   方面1：从稳定性来分析，冒泡排序通过每次冒泡比较进行数据的交换，如果碰到相等的数据，不交换即可；
   方面2：从空间复杂度分析，属于原地排序，O（1）；
   方面3：从时间复杂度分析：包括最好时间复杂度，最坏时间复杂度，加权平均复杂度，一组数据如果已经顺序排序，最好时间复杂度为O（n），如果是逆序排序，最坏时间复杂度为O（n²）；
        有序度，满有序度，逆序度：逆序度=满有序度-有序度，表示了还需要进行排序的交换的次数；冒泡排序最差情况有序度为0，需要进行（n-1）*n/2次排序，最好情况下逆序度为0，已经是有序，则平均时间复杂度为O（n²）;

插入排序：一组数据，分为已排序区间和未排序区间，每次从未排序区间取一个数和已排序区间进行比较，插入合适的位置，这样使得已排序区间一直都是有序的，直到未排序区间数据为0；
     从三个方面来分析，插入排序和冒泡排序结果类似；

选择排序：一组数据，分为已选择区间和未选择区间，每次从未选择区间取一个最小值，将它放到一选择区间的末尾，直到未选择区间数据为0；
     选择排序是不稳定的排序算法；选择排序的最好，最坏，平均时间复杂度都为
O（n²），而冒泡和插入排序都有提前结束的情况，所以选择排序相较之下稍微逊色。

 冒泡排序和插入排序相比较，三个方面都类似，但是冒泡排序需要三个赋制操作，插入排序只需要一个赋值操作，所以相比之下，插入排序更为优秀;

  冒泡排序，插入排序，选择排序：一般实际使用插入排序，冒泡排序和选择排序用于理论学习，插入排序对于小规模的数据比较实用（有些编程语言的排序函数用到），但对于大规模的数据而言，O（n²）的时间复杂度太久，需要O（nlogn）的算法;

  归并排序，快速排序使用了分治的思想
   归并排序：时间复杂度（最好，最坏，平均）都为O（nlogn）,空间复杂度为O（n），是稳定的排序算法；
   
   快速排序：时间复杂度，最好时间复杂度为O（n）,最坏时间复杂度为O（n²），平均复杂度为O（nlogn），只要找准合适的pivot，时间复杂度为O（n²）的概率非常小，空间复 杂度为O（1），不是稳定的排序算法；

 归并排序没有快速排序使用广泛，或许在时间复杂度上可能稍微有优势，但快速排序能通过寻找合适的pivot有效的避免该问题，另外，快速排序是原地排序，因此对于数据规模超大的排序问题，快速排序的优势十分明显。

Java Arrays排序原理?? 尝试设置启动参数，选择排序方法？？
    Arrays.sort() 排序，基本数据类型的排序,比如int[]使用的
 DualPivotQuicksort 双轴快速排序算法 JDK1.7
      <47:插入排序 ；<286:快速排序；否则：双轴快速排序；在排序过程中，根据数据长度自动选择排序算法；

如果是对象数组排序，使用的
TimSort  归并排序的升级版(归并和插入算法的混合版本),旧版本使用的一般的MergeSort  JDK1.7
TimSort数据长度小于32，使用折半插入排序；
普通的MergeSort长度小于7,使用插入排序;

快速排序相比归并排序在空间复杂度上更优越，而时间复杂度上不太逊色，因为是一种不稳定的算法，所以对于基本数据类型的排序，可以选择使用；而对象数组的排序，需要算法具有稳定性，所以选择了归并排序；  


桶排序：将数据分到几个有序的桶里，然后分别对每个桶进行排序（根据数据规模和数据特征选择排序算法），适合数据规模大的情况，且数据范围不大（桶的数量小），适合外部排序（比如磁盘文件），它的时间复杂度为O（n）；

计数排序：桶排序的特殊情况，即每个桶里面的数据大小相同，这样避免了每个桶的排序，一般只能在特定数据场景下使用，比如某个省份数学考试分数排序，0~150分可以分成151个桶；需要理解计数的概念；O(n+k)k指的是数据范围

基数排序：数据有位的权重的概念，就类似123>111，bbc>abc，所以使用该算法，要求数据具有高低位且每个位可以比较，且每位的数据范围比较小（使得可使用线性排序）；比如手机号码的排序；O(dn) d指的是数据维度(数据长度)；将数据位分割，先比较高位数据（使用桶排序或者计数排序）;

线性排序算法是稳定的排序算法，都不是原地排序


一个通用的排序算法？比如Java中Arrays.sort（）。
   线性时间排序（桶排序，计数排序，基数排序）适用于特殊的数据场景，不能够作为通用的算法使用，所以对于较大规模的数据使用nlogn的算法，对于较小规模使用n²的算法。
快速排序最差时间复杂度为O（n²），如何优化避免这种情况（选好轴）？三数取中，五数取中，随机法。


二分查找：基于数组的有序数据进行折半查找，时间复杂度为O（logn），空间复杂度为O（1）;对于小规模数据直接使用顺序查找即可，对于大规模数据，如果太大，不适用于数组结构，也不适用。
  
   求一个数的平方根，精确到小数点后六位? 
如果使用链表进行二分查找呢？需要移动n次指针，以及额外的运算，使得效率不如顺序查找。

二分查找变体？存在多个相等的值，近似存在的问题；
   查找第一个等于给定值的数；查找最后一个等于给定值的数；查找第一个大于等于给定值的数；查找最后一个小于等于给定值得数；

  IP地址省份定位？
  循环有序数组的二分查找？

实际使用中，对于给定数相等值得查找，会使用散列表或者二叉查找树，二分查找更适用于寻找近似值得问题；